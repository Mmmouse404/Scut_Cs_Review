前言：本人是华工19级智科专业的一个小菜鸟，机器学习这门课从我们这一届开始才有考试，因为没有往年的试题可以参考，复习的时候有 点摸不着头脑（主要还是因为上课摸鱼，考试前夕才得知老师划的重点；以及老师的PPT实在是太过凌乱，让人理不清逻辑）。  
目录主要按照老师ppt的目录来，标有三角符号的为老师划的重点。考察内容侧重理解和把理论如何应用到课设中，so两个课设不能摸鱼……每一个要求都要落实。

19级机器学习试卷内容：

 *  结合SVM课设：
    
     *  监督/非监督
     *  系统流程图
     *  如何寻优调参（评估）
     *  非线性如何处理
     *  核函数选择，参数
 *  结合神经网络课设：
    
     *  人工神经网络模型，ReLU的定义
     *  网络结构
     *  使用什么算法，其流程
     *  如何进行网络优化，正则化
 *  其他
    
     *  结合SVM与LR回归目标函数（尤其是损失函数），阐述它们的区别
     *  推导 logistic 回归的目标函数
     *  随机森林算法流程
     *  机器学习三要素；监督学习，非监督学习，强化学习的区别

#### 文章目录 

- [chapter1](#chapter1)
- [chapter2](#chapter2)
    - [2.1 机器学习的整体过程](#21-机器学习的整体过程)
    - [2.2 误差与过拟合](#22-误差与过拟合)
      - [△ \\triangle △ 过拟合与欠拟合及其策略](#-triangle--过拟合与欠拟合及其策略)
    - [2.3 模型选择](#23-模型选择)
    - [2.4 评估方法](#24-评估方法)
      - [△ K折交叉验证法](#-k折交叉验证法)
    - [2.5 性能度量](#25-性能度量)
      - [△ \\triangle △ PR曲线，P和R是什么](#-triangle--pr曲线p和r是什么)
      - [△ \\triangle △ ROC曲线](#-triangle--roc曲线)
      - [△ \\triangle △ 敏感性，特异性](#-triangle--敏感性特异性)
    - [2.6 比较检验\*](#26-比较检验)
    - [2.7 偏差与方差](#27-偏差与方差)
      - [△ \\triangle △ 公式推导](#-triangle--公式推导)
- [chapter3](#chapter3)
    - [3.1 基本形式及概念](#31-基本形式及概念)
    - [3.3  △ \\triangle △ 对数几率回归（Logistic）](#33---triangle--对数几率回归logistic)
    - [3.4  △ \\triangle △ 线性判别分析 (LDA)](#34---triangle--线性判别分析-lda)
    - [3.5 多分类学习](#35-多分类学习)
    - [3.6  △ \\triangle △ 类别不平衡问题](#36---triangle--类别不平衡问题)
- [chapter4](#chapter4)
      - [△ \\triangle △ 近似线性可分问题](#-triangle--近似线性可分问题)
      - [△ \\triangle △ 核函数怎么选取](#-triangle--核函数怎么选取)
      - [△ \\triangle △ SVM寻优调参](#-triangle--svm寻优调参)
      - [△ \\triangle △ 软间隔SVM](#-triangle--软间隔svm)
      - [△ \\triangle △ 损失函数对比](#-triangle--损失函数对比)
      - [△ \\triangle △ SVM 与 logistic 回归的区别](#-triangle--svm-与-logistic-回归的区别)
      - [习题](#习题)
- [chapter5](#chapter5)
      - [△ \\triangle △ 三要素](#-triangle--三要素)
    - [5.1 人工神经元模型](#51-人工神经元模型)
      - [△ \\triangle △ MP神经模型](#-triangle--mp神经模型)
      - [△ \\triangle △ sigmoid 函数](#-triangle--sigmoid-函数)
      - [△ \\triangle △ 修正线性单元 ReLU](#-triangle--修正线性单元-relu)
    - [5.2 网络结构](#52-网络结构)
    - [5.3  △ \\triangle △ 前馈神经网络（多层感知机）](#53---triangle--前馈神经网络多层感知机)
    - [5.4  △ \\triangle △ 反向传播算法（BP）](#54---triangle--反向传播算法bp)
      - [△ \\triangle △ 如何跳出局部最小](#-triangle--如何跳出局部最小)
    - [5.5 优化问题](#55-优化问题)
- [chapter6](#chapter6)
    - [6.1 深度学习初探](#61-深度学习初探)
    - [6.2 卷积神经网络 CNN](#62-卷积神经网络-cnn)
      - [△ \\triangle △ 卷积层](#-triangle--卷积层)
      - [△ \\triangle △ CNN的典型结构](#-triangle--cnn的典型结构)
      - [△ \\triangle △ 残差网络](#-triangle--残差网络)
    - [6.3 循环神经网络 RNN](#63-循环神经网络-rnn)
      - [△ \\triangle △ CNN与RNN的区别](#-triangle--cnn与rnn的区别)
    - [6.4 网络优化与正则化](#64-网络优化与正则化)

## chapter1 

> 机器学习（Machine Learning，ML）是指从有限的观测数据中学习（或“猜测”）出具有一般性的规律，并将这些规律应用到未观测样本上的方法。
> 
> 深度学习是机器学习的一个子问题，其主要目的是从数据中自动学习到有效的特征表示。
> 
> 深度学习可以使用神经网络，也可以使用其他模型。神经网络的误差反向传播算法可以很好地解决贡献度分配问题（CAP）。

 *  什么是机器学习？

机器学习任务本质上是根据特征判断性质，根据经验解决问题。基本流程是基于数据产生模型，利用模型预测输出。主要研究内容是模型（学习算法）。目标是让模型有较好泛化能力。

![](https://i-blog.csdnimg.cn/blog_migrate/8ef43051fca60e89ea36903ccd7d570e.png)

机器学习的目标是找到一个模型来近似真实映射函数g(x)或真实条件概率分布 p (y|x)。

由于我们不知道真实的映射函数 g(x) 或条件概率分布 p (y|x) 的具体形式， 只能根据经验来确定一个假设函数集合F，称为假设空间(Hypothesis Space)。

然后通过观测其在训练集 D 上的特性，从中选择一个理想的假设(Hypothesis) f∗ ∈F。

假设空间 F 通常为一个参数化的函数族F = \{f(x;θ)|θ ∈ Rm\}, 其中 f (x; θ) 为假设空间中的模型，θ 为一组可学习参数，m 为参数的数量。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a1798b1c9da688910ae83396a76454ad.png)

![](https://i-blog.csdnimg.cn/blog_migrate/8ff13882234d441c746bbcdac23438c4.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c9f5e841e7c451b27f7998f1bfcbe68a.png)

> ① 假设函数直观理解：对于数据开始是不知道特征的，假设其服从某个函数 规律或者某种分布；
> 
> ② 参数：假设函数中所含有的参数，本质就是学习器模型。学习的过程就是 确定参数的过程。
> 
> ③ 损失函数：为了求参数（确定学习器模型），找到的一个可以 衡量模型好坏的度量函数。损失函数是一个 非负实数函数，用来量化模型预测和真实标签之间的差异。
> 
> ④ 最优化过程：让度量函数最大化或者最小化，设计算法，最终确定出参数 的过程。最优化与机器学习的交汇点

## chapter2 

#### 2.1 机器学习的整体过程 

数据获取、特征工程、模型选择、模型训练、模型评估、超参数条件、预测

> 机器学习过程中,通过确定两方面的参数来找到泛化性能最好的函数:
> 
> 函数参数：也就是我们通常所说的w和b，这类参数可以通过各种最优化算法自动求得;  
> 模型参数：比如多项式回归中的多项式次数,规则化参数入等(即超参数)，一般在模型训练之前通过手工指定（当然也可以采用网格法等算法进行寻优)。
> 
> 确定模型超参数的过程称为模型选择(从Algorithm选择Models)。

#### 2.2 误差与过拟合 

 *  错误率
    
    错误率即错分样本的占比：E = a/m
 *  误差
    
    ① 误差： 实际预测输出和样本真实输出之间的差异。
    
    ② 经验误差 / 训练误差：学习器在训练集上的误差。训练后已知。
    
    ③ 测试误差：测试集上的误差。
    
    ④ 泛化误差：在新样本上的误差（即未知样本上的，测试误差只是其中一部分）。
    
     *  机器学习的目的是通过现有样本，学习到泛化误差小的预测模型；
     *  由于事先并不知道新样本的特征，我们只能努力使经验误差最小化；
     *  泛化误差越小越好，而经验误差不一定越小越好，有可能出现过拟合。

#####  △ \\triangle △ 过拟合与欠拟合及其策略 

 *  过拟合与欠拟合
    
     *  过拟合（训练集误差小，测试集误差大）“低偏差，高方差”
        
        学习器把训练样本学习的“太好”，将训练样本本身的特点当做所有样本的一般性质（不考虑数据噪声），导致泛化性能下降。
        
        解决：
        
        1.  增加训练样本数量
        2.  正则化
        3.  降维
        4.  集成学习方法
        5.  减少模型复杂度
     *  欠拟合（训练集测试集误差均大）“高偏差，低方差”  
        对训练样本的一般性质尚未学好。
        
        解决：
        
        1.  添加新特性
        2.  增加模型复杂度
        3.  减小正则化系数
        
        > 决策树:拓展分支  
        > 神经网络:增加训练轮数

#### 2.3 模型选择 

多候选模型泛化误差进行评估，选择泛化误差最小的模 型

#### 2.4 评估方法 

前提：假设测试样本是从样本真实分布中独立同分布采用得到。

原则：测试集与训练集互斥（互不含有共同样本）

 *  留出法
    
     *  直接将数据集划分为两个互斥集合
     *  训练/测试集划分要尽可能保持数据分布的一致性
     *  一般若干次随机划分、重复实验取平均值
     *  训练/测试样本比例通常为2:1~4:1

#####  △ K折交叉验证法 

 *  k折交叉验证法
    
    将数据集分层采样划分为k个大小相似的互斥子集，每次用k-1个子集的并集作为训练集，余下的一个子集作为测试集，最终返回k个测试结果的均值，k最常用的取值是10.
    
    特例 - 留一法（每次只留下一个样本）
 *  自助法
    
     *  留出法和交叉验证法都是采用分层采样的方式进行采样
     *  自助法使用有放回的重复采样的方式进行采样
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/eabaf719580d43b1af71b03496b29c8a.png)
    
     *  从初始数据集中产生多个不同的训练集，对集成学习有很大的好处
     *  对于那些数据集小、难以有效划分训练/测试集时很有用，但是由于该方法改变了数据的初始分布导致会引入估计偏差
 *  总结
    
     *  对于数据量充足的时候，通常采用留出法或者 k 折交叉验证法来进行训练/测试集的划分；
     *  对于数据集小且难以有效划分训练/测试集时使用自助法；
     *  对于数据集小且可有效划分的时候最好使用留一法来进 行划分，因为这种方法最为准。

#### 2.5 性能度量 

性能度量是衡量模型泛化能力的评价标准，反映了任务需求；使用不同的性能度量往往会导致不同的评判结果

 *  回归模型
    
     *  均方误差
        
        ![](https://i-blog.csdnimg.cn/blog_migrate/0344c2eef9a36bf9b923aaa68d81dd60.png)
 *  分类模型
    
     *  错误率：分类错误的占总样本的比例
        
        ![](https://i-blog.csdnimg.cn/blog_migrate/be25dc0dbc146155b73f6efd8a3d06a8.png)
     *  精度（准确率）：分类正确的占总样本的比例
        
        ![](https://i-blog.csdnimg.cn/blog_migrate/015caf36052d0b5810b9e7c966f67f83.png)
     *  查全率、查准率
        
        准确率是所有类别整体性能的平均，如果希望对每个类都进行 性能估计，就需要计算查准率和查全率
        
        ![](https://i-blog.csdnimg.cn/blog_migrate/68435f91e31530fbdacd8d56902695dc.png)
        
         *  查准率（precision）：预测出来的正例中正确的比例。（竖）
         *  查全率（recall）：正例被预测出来的比例。（横）

#####  △ \\triangle △ PR曲线，P和R是什么 

 *  PR曲线

![](https://i-blog.csdnimg.cn/blog_migrate/75fc8271eafa3e9acb50dd0ae4b10928.png)

![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZAq1AkDL-1640596268110)(C:\Users\lenovo.LAPTOP-MVJJVS9E\AppData\Roaming\Typora\typora-user-images\image-20211225215844789.png)]](https://i-blog.csdnimg.cn/blog_migrate/8548df8acb350931bdda2d7516246f3d.png)  
两条曲线有交叉时难以判断面积大小，通过以下方法度量分类器性能：

BEP法

（0,0）到（1,1）直线与PR曲线的交点，即 “ 查全率 = 查准率 ” 时的取值。

F度量

![​		](https://i-blog.csdnimg.cn/blog_migrate/256c6e309c233702d7008c2d3d861479.png)

![​      ](https://i-blog.csdnimg.cn/blog_migrate/5b72fe5426884205bcdc6af123b5c118.png)

#####  △ \\triangle △ ROC曲线 

 *  ROC曲线 / AUC
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/3e57d8594374f3691873dc28c0be6c60.png)
    
    横轴：假阳性率  F P R = F P F P + T N FPR=\\dfrac\{FP\}\{FP+TN\} FPR=FP\+TNFP 纵轴：真阳性率（ 查全率）  T P R = T P T P + F N TPR=\\dfrac\{TP\}\{TP+FN\} TPR=TP\+FNTP
    
    理想点为（0,1）
    
    若某个学习器的ROC曲线被另一个学习器的曲线“包住”，则后者性能优于前者；
    
    否则如果曲线交叉，可以根据ROC曲线下面积大小进行比较，也即AUC值.
    
    AUC衡量了样本预测的排序质量。
    
    作用：(1) 选择最佳的学习器模型、舍弃次佳的模型。 (2) 在同一模型中设 定最佳阈值。
    
    在做决策时，ROC 分析能不受成本／效益的影响，给出客观中立的建议

#####  △ \\triangle △ 敏感性，特异性 

 *  查准率 P：预测出来的正例中正确的比例。  P = T P T P + F P P=\\dfrac\{TP\}\{TP+FP\} P=TP\+FPTP
 *  查全率 R：正例被预测出来的比例。  R = T P T P + F N R=\\dfrac\{TP\}\{TP+FN\} R=TP\+FNTP
 *  真阳性率 TPR：正例被预测出来的比例。  T P R = T P T P + F N = R TPR=\\dfrac\{TP\}\{TP+FN\}=R TPR=TP\+FNTP=R
 *  假阳性率 FPR：负例被检测错误的比例（误诊）。 F P R = F P F P + T N FPR=\\dfrac\{FP\}\{FP+TN\} FPR=FP\+TNFP
 *  真阴性率 TNR：负例被预测出来的比例。  T N R = T N T N + F P TNR=\\dfrac\{TN\}\{TN+FP\} TNR=TN\+FPTN
 *  假阴性率 FNR：正例被检测错误的比例（漏诊）。 F N R = F N F N + T P FNR=\\dfrac\{FN\}\{FN+TP\} FNR=FN\+TPFN
 *  敏感性：正例被检测出来的比例  S n = T P T P + F N = T P R = 1 − F N R Sn=\\dfrac\{TP\}\{TP+FN\}=TPR=1-FNR Sn=TP\+FNTP=TPR=1−FNR
 *  特异性：负例被检测出来的比例  S p = T N T N + F P = T N R = 1 − F P R Sp=\\dfrac\{TN\}\{TN+FP\}=TNR=1-FPR Sp=TN\+FPTN=TNR=1−FPR

![     ](https://i-blog.csdnimg.cn/blog_migrate/d6e03571ff23106b9304c3ca6872e9fb.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/baeda8f001800bbebf0705fce060d43e.png)

#### 2.6 比较检验\* 

![](https://i-blog.csdnimg.cn/blog_migrate/af9515baf2c7cc87d264e23baa193c79.png)

 *  PAC理论，归纳偏好，NFL理论（不懂老师为啥把这几个理论放在这个地方，我赌它不考嘿嘿，占个坑证明我知道有这玩意）
 *  两个学习器比较
    
     *  交叉验证 t 检验
     *  McNemar 检验
 *  多个学习器比较
    
     *  Friedman检验 + Nemenyi检验（我堵它不考）

#### 2.7 偏差与方差 

偏差体现了学习器预测的准确度，而方差体现 了学习器预测的稳定性。通过对泛化误差的进行分解，可以得到：

`期望泛化误差 = 方差 + 偏差`

#####  △ \\triangle △ 公式推导 

![     ](https://i-blog.csdnimg.cn/blog_migrate/5d4f433cfdd4a882e5d5744ce52566c4.png)

 *  偏差度量了学习算法期望预测与真实结果的偏离程度；即刻画了学习算法本身的拟合能力；
 *  方差度量了同样大小训练集的变动所导致的学习性能的变化；即刻画了数据扰动所造成的影响，体现学习器的稳定性。
 *  噪声表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界；即刻画了学习问题本身的难度。

![](https://i-blog.csdnimg.cn/blog_migrate/7f987b0ad90d2cd72130487e0de855ad.png)

> 偏差（bias）可以看成模型预测与真实样本的差距，想要得到 low bias，就得复杂化模型，但是容易造成过拟合。方差（variance）可以看成模型在测试集上的表现，想要得到 low variance，就得简化模型，但是容易造成欠拟合。实际应用中，偏差和方差是需要权衡的。若模型在训练样本和测试集上都表现的不错，偏差和方差都会比较小，这也是模型比较理想的情况。

## chapter3 

#### 3.1 基本形式及概念 

 *  基本形式： f ( x ) = w 1 x 1 + w 2 x 2 + ⋯ + w d x d + b f(x)=w\_\{1\}x\_\{1\}+w\_\{2\}x\_\{2\}+\\dots+w\_\{d\}x\_\{d\}+b f(x)=w1x1\+w2x2\+⋯\+wdxd\+b
    
     x x x：属性描述的示例， x i x\_\{i\} xi：是 `x` 在第 `i` 个属性上的取值.
    
    向量形式： f ( x ) = w T x + b f(x)=w^\{T\}x+b f(x)=wTx\+b
    
     w = ( w 1 , w 2 , … , w d ) w=(w\_\{1\},w\_\{2\},\\dots,w\_\{d\}) w=(w1,w2,…,wd)
 *  优点
    
     *  形式简单、易于建模
     *  可解释性
     *  非线性模型的基础
     *  引入层级结构或高维映射
 *  目的
    
    试图学得一个线性模型以尽可能准确地预测实值输出标记
 *  模型求解
    
    均方误差最小化：最小二乘法
    
     *  假设只有一个属性
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/491986c3d952425ecf5ca17f66c6fea6.png)
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/00c1c196f8718da963fd1284fec1b22c.png)
    
     *  多元线性回归
        
        ![](https://i-blog.csdnimg.cn/blog_migrate/0bef2252af91807ca54077882ccdcaf2.png)

#### 3.3  △ \\triangle △ 对数几率回归（Logistic） 

 *  广义线性模型
    
    逼近单调可微函数 `g(·)` ，则有：  
     y = g − 1 ( w T x + b ) y=g^\{-1\}(w^Tx+b) y=g−1(wTx\+b)
 *  二分类任务： z = w T x + b z=w^\{T\}x+b z=wTx\+b
    
    如何将分类标记与线性回归模型连接起来？  
     y = \{ 0 , z < 0 0.5 , z = 0 1 , z > 0 y=\\left\\\{ \\begin\{aligned\} 0, z<0 \\\\ 0.5, z=0\\\\ 1, z>0 \\end\{aligned\} \\right. y=⎩⎪⎨⎪⎧0,z<00.5,z=01,z>0  
    单位阶跃函数是一个不错的选择！
    
    但是 – 阶跃函数不连续 -\_- II 因此需要寻找一个单调可微的近似函数
 *  `Logistics` 函数
    
    是一种`sigmoid` 函数  
     y = 1 1 + e − z y=\\dfrac\{1\}\{1+e^\{-z\}\} y=1\+e−z1  
     l n y 1 − y = w T + b ln\\dfrac\{y\}\{1-y\}=w^T+b ln1−yy=wT\+b
    
     *  模型求解 （占坑）
        
         *  最大似然法
         *  凸优化理论
         *  经典数值优化算法
            
             *  梯度下降法
             *  牛顿法
             *  共轭梯度法

#### 3.4  △ \\triangle △ 线性判别分析 (LDA) 

 *  类内间距小，类间间距大

详见模式识别课本

#### 3.5 多分类学习 

 *  一对多
    
    C个判别函数
 *  一对一
    
     C ( C − 1 ) 2 \\dfrac\{C(C-1)\}\{2\} 2C(C−1) 个判别函数

#### 3.6  △ \\triangle △ 类别不平衡问题 

![](https://i-blog.csdnimg.cn/blog_migrate/d2b2c2fd2af866c7a060f876ec77c1bf.png)

## chapter4 

#####  △ \\triangle △ 近似线性可分问题 

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/39c9883c6358adc0c7f4f9b8c53d36d7.png)

![            ](https://i-blog.csdnimg.cn/blog_migrate/eca5fe1514e55b74458289ae9b6ba392.png)

#####  △ \\triangle △ 核函数怎么选取 

![](https://i-blog.csdnimg.cn/blog_migrate/182c707a5ca31ac57dbfffa4012073cc.png)

> #### 请简述在线性不可分样本中SVM引入核函数的目的，常见的核函数以及它们的使用场景和效果。 
> 
> 答： ① 我们遇到线性不可分的样例时，常用做法是把样本特征映射到高维空间中去。 但是遇到线性不可分的样本，一律映射到高维空间，那么这个维度大小是会高到令人恐怖的。 此时，核函数就体现出它的价值了，核函数的价值在于它虽然也是将特征进行从低维到高维的转换， 但核函数好在它在低维上进行计算，而将实质上的分类效果（利用了内积）表现在了高维上， 这样避免了直接在高维空间中的复杂计算，真正解决了SVM线性不可分的问题。
> 
> ② 事实上，核函数的研究非常的早，要比SVM出现早得多，当然， 将它引入SVM中是最近二十多年的事情。对于从低维到高维的映射，核函数不止一个。
> 
> 1) \*\*线性核函数（Linear Kernel）\*\*适用于线性可分的样本集上，分类效果良好：
> 
> ![img](https://i-blog.csdnimg.cn/blog_migrate/85250969d9589f554acc0ff2c3028f0d.png)

#####  △ \\triangle △ SVM寻优调参 

 *  网格搜索
 *  交叉验证
 *  启发式算法
    
    ……

#####  △ \\triangle △ 软间隔SVM 

\[【机器学习】支持向量机——软间隔（SVM中篇）\_慕课手记 (imooc.com)\](https://www.imooc.com/article/266377\#:~:text=软间隔是相对于硬间隔定义的。 上节中介绍的线性可分的SVM算法，属于硬间隔。 硬间隔,，就是存在所有样本必须划分正确的约束条件，即所有样本必须 严格满足 ： 所以从这个角度分析，上篇介绍的算法，是在硬间隔定义的基础之上推导的。)

#####  △ \\triangle △ 损失函数对比 

![](https://i-blog.csdnimg.cn/blog_migrate/bc5cb78155965b610bb9aff8748f495a.png)

![](https://i-blog.csdnimg.cn/blog_migrate/6ae0448e3272bd546084fc13eee28785.png)

![](https://i-blog.csdnimg.cn/blog_migrate/e835f05f04bbc1d9d7a98c59085b6976.png)

#####  △ \\triangle △ SVM 与 logistic 回归的区别 

 *  logistic
    
     *  输出具有自然的概率意义，再给出预测标记的同时给出了概率意义
     *  可以直接用于多分类任务
     *  损失函数是光滑的单调函数，其解依赖于更多训练样本，预测开销更大。
     *  Logistic回归目标函数是最大化后验概率
 *  SVM
    
     *  输出不具概率意义，要得到概率输出需要进行特殊处理
     *  不能直接用于多分类，需要进行推广
     *  hinge损失具有一块“平坦”的零区域，使得SVM的解具有稀疏性
     *  SVM可以实现结构风险最小化
     *  SVM可以有效避免模型过拟合

> 联系：  
> 1、LR和SVM都可以处理分类问题，且一般都用于处理线性二分类问题（在改进的情况下可以处理多分类问题）  
> 2、两个方法都可以增加不同的正则化项，如L1、L2等等。所以在很多实验中，两种算法的结果是很接近的。  
> 区别：  
> 1、LR是参数模型，SVM是非参数模型。  
> 2、从目标函数来看，区别在于逻辑回归采用的是Logistical Loss，SVM采用的是hinge loss.这两个损失函数的目的都是增加对分类影响较大的数据点的权重，减少与分类关系较小的数据点的权重。  
> 3、SVM的处理方法是只考虑Support Vectors，也就是和分类最相关的少数点，去学习分类器。而逻辑回归通过非线性映射，大大减小了离分类平面较远的点的权重，相对提升了与分类最相关的数据点的权重。  
> 4、逻辑回归相对来说模型更简单，好理解，特别是大规模线性分类时比较方便。而SVM的理解和优化相对来说复杂一些，SVM转化为对偶问题后,分类只需要计算与少数几个支持向量的距离,这个在进行复杂核函数计算时优势很明显,能够大大简化模型和计算。  
> 5、Logic 能做的 SVM能做，但可能在准确率上有问题，SVM能做的Logic有的做不了。
> 
> 答案来源：机器学习常见面试问题（一）
> 
> 10.LR与线性回归的区别与联系？
> 
> @nishizhen  
> 个人感觉逻辑回归和线性回归首先都是广义的线性回归，  
> 其次经典线性模型的优化目标函数是最小二乘，而逻辑回归则是似然函数，  
> 另外线性回归在整个实数域范围内进行预测，敏感度一致，而分类范围，需要在\[0,1\]。逻辑回归就是一种减小预测范围，将预测值限定为\[0,1\]间的一种回归模型，因而对于这类问题来说，逻辑回归的鲁棒性比线性回归的要好。  
> @乖乖癞皮狗：逻辑回归的模型本质上是一个线性回归模型，逻辑回归都是以线性回归为理论支持的。但线性回归模型无法做到sigmoid的非线性形式，sigmoid可以轻松处理0/1分类问题。

> svm 的损失函数折叶损失（hinge loss）是针对样本的标记类别之外的其他类别进行损失计算的，也就是说标记类别不计入损失，其他类别计算损失并累加作为某个样本的损失。而softmax的损失函数交叉熵损失（cross-entropy loss）只跟某个样本的标记类别相关，根据该标记类别的概率计算损失值，而不考虑标记类别之外的其他类别。从上面的公式就可以得出这个结论。

##### 习题 

1.简述svm原理：

svm是一种二分类模型，基本思想是寻找能够正确划分训练集数据并且间隔最大的分离超平面。（间隔最大是它有别于感知机）

（1）当训练样本线性可分时，通过硬间隔最大化，学习一个线性分类器，即线性可分支持向量机；

（2）当训练数据近似线性可分时，引入松弛变量，通过软间隔最大化，学习一个线性分类器，即线性支持向量机；

（3）当训练数据线性不可分时，通过使用核技巧及软间隔最大化，学习非线性支持向量机。

注：以上各SVM的数学推导应该熟悉：硬间隔最大化（几何间隔）—学习的对偶问题—软间隔最大化（引入松弛变量）—非线性支持向量机（核技巧）。

2.SVM为什么采用间隔最大化？

一方面，分离超平面有无穷个，但是间隔最大的分离超平面只有一个，因此解是唯一的；另一方面，间隔最大的分离超平面对于未知实例的泛化能力最强。

3.为什么引入核函数？

当样本在原始空间线性不可分的时候，可以将样本从原始空间映射到更高维的特征空间，使得样本在这个特征空间内线性可分。引入映射后的对偶问题：

在学习预测中，只定义核函数K(x,y)，而不是显式的定义映射函数ϕ。因为特征空间维数可能很高，甚至可能是无穷维，因此直接计算ϕ(x)·ϕ(y)是比较困难的。相反，直接计算K(x,y)比较容易（即直接在原来的低维空间中进行计算，而不需要显式地写出映射后的结果）。

核函数的定义：K(x,y)=<ϕ(x),ϕ(y)>，即在特征空间的内积等于它们在原始样本空间中通过核函数K计算的结果。

除了 SVM 之外，任何将计算表示为数据点的内积的方法，都可以使用核方法进行非线性扩展。

4、样本失衡会对SVM的结果产生影响吗？

答：会，超平面会靠近样本少的类别。因为使用的是软间隔分类，而如果对所有类别都是使用同样的惩罚系数，则由于优化目标里面有最小化惩罚量，所以靠近少数样本时，其惩罚量会少一些。比如：假设理想的分隔超平面是大样本中有很多数据到该超平面的函数距离是小于1的，而小样本中是只有少数样本的函数距离小于1的。但是由于惩罚系数相同，实际算法得到的超平面会往小样本数据靠近。

样本失衡的解决办法：

1)、对多数类和和少数类采用不同的惩罚因子，对正例和负例赋予不同的C值，例如正例远少于负例，则正例的C值取得较大，这种方法的缺点是可能会偏离原始数据的概率分布；

2)、对训练集的数据进行预处理即对数量少的样本以某种策略进行采样，增加其数量或者减少数量多的样本，典型的方法如：随机插入法，缺点是可能出现 overfitting，较好的是：Synthetic Minority Over-sampling TEchnique(SMOTE)，其缺点是只能应用在具体的特征空间中，不适合处理那些无法用特征向量表示的问题，当然增加样本也意味着训练时间可能增加；

3)、基于核函数的不平衡数据处理。

5.核函数如何选取？

在选用核函数的时候，如果我们对我们的数据有一定的先验知识，就利用先验来选择符合数据分布的核函数；如果不知道的话，通常使用交叉验证的方法，来试用不同的核函数，误差最小的即为效果最好的核函数，或者也可以将多个核函数结合起来，形成混合核函数。在吴恩达的课上，也曾经给出过一系列的选择核函数的方法：

如果特征的数量大到和样本数量差不多，则选用LR或者线性核的SVM；

如果特征的数量小，样本的数量正常，则选用SVM+高斯核函数；

如果特征的数量小，而样本的数量很大，则需要手工添加一些特征从而变成第一种情况（选用LR或者线性核的SVM是为了避免造成庞大的计算量）。

6.SVM怎么防止过拟合 ?

引入松弛变量：

7.svm优缺点？

优点：适用于高维数据；能够处理非线性特征之间的相互作用；无需依赖整个数据，只依赖于支持向量；

占用内存小，泛化能力好。

缺点：当观测样本很多时，效率并不是很高；有时候很难找到一个合适的核函数

## chapter5 

#####  △ \\triangle △ 三要素 

> 决定人工神经网络特性的三大要素：
> 
> • 激励函数：神经元不同数学模型主要区别在于不同的激励函数，反应输出与激活状态关系的函数
> 
> • 拓扑结构：分布式存储记忆、分布式信息处理、高度互连性、高度并行性和结构可塑性。
> 
> • 学习算法（学习规则，训练规则，训练算法）：通过学习训练，不断改变网络连接权值以及拓扑结构，使 得网络输出接近期望输出。本质是：可变权值的动态调整

![](https://i-blog.csdnimg.cn/blog_migrate/b27ea75cd65541672aa245457c4ff7f5.png)

#### 5.1 人工神经元模型 

> 人工神经元（Artificial Neuron），简称神经元（Neuron），是构成神经网络的基本单元，其主要是模拟生物神经元的结构和特性，接受一组输入信号并 产出输出。

#####  △ \\triangle △ MP神经模型 

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0039bb3ae91b684d98d47ed56e3a3a07.png)

> 结合M-P模型示意图来看，对于某一个神经元j，它可能接受同时接受了许多个输入信号，用χi表示。
> 
> 由于生物神经元具有不同的突触性质和突触强度，所以对神经元的影响不同，我们用权值ωij来表示，其大小则代表了突出的不同连接强度。
> 
> θj表示为一个阈值（threshold），或称为偏置（bias），超过阈值为兴奋，低于是抑制。
> 
> 由于累加性，我们对全部输入信号进行累加整合，相当于生物神经元中的膜电位（水的变化总量），其值就为：
> 
> ![img](https://i-blog.csdnimg.cn/blog_migrate/fe00734231b5cf357c35bf9cf7784f47.png)

 *  激活函数
    
    > 为了增强网络的表示能力和学习能 力，激活函数需要具备以下几点性质：
    > 
    > 1.  连续并可导（允许少数点上不可导）的非线性函数。可导的激活函数可以 直接利用数值优化的方法来学习网络参数。
    > 2.  激活函数及其导函数要尽可能的简单，有利于提高网络计算效率。
    > 3.  激活函数的导函数的值域要在一个合适的区间内，不能太大也不能太小， 否则会影响训练的效率和稳定性。

#####  △ \\triangle △ sigmoid 函数 

一类S型曲线函数，为两端饱和函数

![](https://i-blog.csdnimg.cn/blog_migrate/f2909b223b3efd597dfbe226a7db858f.png)

 *  Logistic
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/1552cf9db662ad598d6d6533fb8206fd.png)
 *  Tanh
    
    Tanh函数可以看作是放大并平移的Logistic函数，其值域是(−1, 1)。
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/8d0812d0c8a4af7e829b250d29ee3ea6.png) ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2ab8c895ae6bb686411910e227623194.png)
    
    非零中心化的输出会使得其后一层的神经元的输入发生偏置偏移，并进一步使得梯度下降的收敛速度变慢。
 *  Hard-Logistic 和 Hard-Tanh
    
    这两个激活函数计算开销大，可以使用分段函数近似
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/e85ec84fc38df0fcb257b8709aa82c06.png)
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/0835a947fde1522d84a94687db4e5053.png)
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/28f9d0150f8cc1ccf08bf60697442fd0.png)

#####  △ \\triangle △ 修正线性单元 ReLU 

斜坡函数

![](https://i-blog.csdnimg.cn/blog_migrate/50edc96fd93f7d80cc70df3db4cf7dae.png)

优点：计算更加高效；具有很好的稀疏性；在一定程度上缓解了神经网络的梯度消失问题，加速梯度下降 的收敛速度。

缺点：输出是非零中心化的，给后一层的神经网络引入偏置偏移， 会影响梯度下降的效率；

死亡ReLU问题。

 *  带泄露的ReLU
 *  带参数的ReLU
 *  ELU
 *  softplus
 *  Swish函数
 *  Maxout单元

#### 5.2 网络结构 

 *  前馈网络
 *  反馈网络（有记忆）
 *  图网络

#### 5.3  △ \\triangle △ 前馈神经网络（多层感知机） 

![](https://i-blog.csdnimg.cn/blog_migrate/fab6675833f7f690b6212c93979d6bb0.png)

前馈网络：神经元之间不存在同层连接也不存在跨层连接，即网络中无环或者回路。

每层神经元与下一层神经元之间完全互连

神经元之间不存在同层连接

神经元之间不存在跨层连接

 *  多层前馈网络有强大的表示能力，只需一个包含足够多神经元的隐层 , 多层前馈神经网络就能以任意精度逼近任意复杂度的连续函数。

#### 5.4  △ \\triangle △ 反向传播算法（BP） 

推导过程见模式识别PPT

链式法则

![](https://i-blog.csdnimg.cn/blog_migrate/cbb21cfa496d74d1b3b609ac19abcc52.png)

![](https://i-blog.csdnimg.cn/blog_migrate/5bd1e2a58371d442a6fa7304b15eb0a1.png)

#####  △ \\triangle △ 如何跳出局部最小 

 *  以多组不同参数值初始化多个神经网络，按标准方法训练，迭代停止后，取其中误差最小的解作为最终参数。
 *  模拟退火
 *  使用随机梯度下降，即在计算梯度时加入了随机因素，使得在局部最小时，计算的梯度仍可能不为0，从而迭代可以继续进行。
 *  遗传算法

#### 5.5 优化问题 

 *  非凸优化问题
 *  梯度消失问题

> 由于Sigmoid型函数的饱和性，饱和区的导数更是接近于0。这样，误差经过每一层传递都会不断衰减。当网络层数很深时，梯度就会不停的衰减，甚至消 失，使得整个网络很难训练。这就是所谓的梯度消失问题（Vanishing Gradient Problem），也叫梯度弥散问题。
> 
> 在深层神经网络中，减轻梯度消失问题的方法有很多种。一种简单有效的方式是使用导数比较大的激活函数，比如ReLU等。

其他

 *  如何设置隐层神经元的个数仍然是个未决问题. 实际应用中通常使用“试错法”调整
 *  深度学习
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/7a19c232afaa897ac2b29367e93a9681.png)
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/21a43cb9d073de0d0ac941dcae1907cc.png)

## chapter6 

#### 6.1 深度学习初探 

深度学习 ≠ 神经网络

> 深度学习是机器学习的一个子问题，其主要目的是从数据中自动学习到有效的特征表示。
> 
> 深度学习可以使用神经网络，也可以使用其他模型。神经网络的误差反向传播算法可以很好地解决贡献度分配问题（CAP）。

#### 6.2 卷积神经网络 CNN 

 *  全连接前馈神经网络
    
     *  权重矩阵的参数多
     *  很难提取局部不变特征（如缩放，平移，旋转等不影响其语义特征）
 *  卷积神经网络
    
     *  一种前馈神经网络
     *  局部连接，权重共享，空间或时间上次采样
     *  滑步步长 S , 零填充 P
        
        ![](https://i-blog.csdnimg.cn/blog_migrate/d76ac2aa43346bd317f094f133e48038.png)
     *  类型
        
        卷积的结果按输出长度不同可以分为三类：  
        窄卷积：步长 𝑇 = 1 ，两端不补零 𝑃 = 0 ，卷积后输出长度为 𝑀 − 𝐾 + 1  
        宽卷积：步长 𝑇 = 1 ，两端补零 𝑃 = 𝐾 − 1 ，卷积后输出长度 𝑀 + 𝐾 − 1  
        等宽卷积：步长 𝑇 = 1 ，两端补零 𝑃 =(𝐾 − 1)/2 ，卷积后输出长度 𝑀
     *  卷积操作的目标：提取特征。
     *  特征映射（Feature Map）：图像经过卷积后得到的特征。
     *  卷积核看成一个特征提取器

#####  △ \\triangle △ 卷积层 

输入：D个特征映射 M×N×D  
输出：P个特征映射 M′×N′×P

![   ](https://i-blog.csdnimg.cn/blog_migrate/0f4a22e05035aeb3a25ab18dd4c34464.png)

![](https://i-blog.csdnimg.cn/blog_migrate/1ac90f9b2503c66f0add1b49b3af539d.png)

 *  汇聚层
    
     *  卷积层虽然可以显著减少连接的个数，但是每一个特征映射的神经元个数并没有显著减少。
     *  汇聚层的作用是进行特征选择，降低特征数量，并从而减少参数数量。
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/a599357393faba70839c7f009efa0775.png)

#####  △ \\triangle △ CNN的典型结构 

![](https://i-blog.csdnimg.cn/blog_migrate/465292da502d83927fc66f21947d70de.png)

> 一个卷积块为连续M 个卷积层和b个汇聚层（M通常设置为2 ∼ 5，b为0或1）。一个卷积网络中可以堆叠N 个连续的卷积块，然后在接着K 个全连接层（N 的取值区间比较大，比如1 ∼ 100或者更大；K一般为0 ∼ 2）。

#####  △ \\triangle △ 残差网络 

残差网络（ResNet）是通过给非线性的卷积层增加直连边的方式来提高信息的传播效率。

假设在一个深度网络中，我们期望一个非线性单元（可以为一层或多层的卷积层）f(x,θ)去逼近一个目标函数为h(x)。

![](https://i-blog.csdnimg.cn/blog_migrate/3b81cf5d6c8dbc769baf69debf8e48e1.png)

 *  残差单元由多个级联的（等长）卷积层和一个跨层的直连边组成，再经过ReLU激活后得到输出。
 *  残差网络就是将很多个残差单元串联起来构成的一个非常深的网络。
    
    ![<img src="C:\Users\lenovo.LAPTOP-MVJJVS9E\AppData\Roaming\Typora\typora-user-images\image-20211226202034038.png" alt="image-20211226202034038](https://i-blog.csdnimg.cn/blog_migrate/dc36389192b45f3eacd56c89c065019a.png)  
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a864a67eb3a3dd62353adec69838af53.png)
 *  残差网络与普通网络的区别
    
    普通卷积网络：在网络层数加深的时候，会出现梯度消失问题，精度下降。
    
    而残差网络：
    
    > 假定某段神经网络的输入是x，期望输出是H(x)。
    > 
    > 如果已经学习到较饱和的准确率（或者当发现下层的误差变大时），那么接下来的学习目标就转变为恒等映射的学习，也就是使输入x近似于输出H(x)，以保持在后面的层次中不会造成精度下降。
    > 
    > 在上图的残差网络结构图中，通过“shortcut connections（捷径连接）”的方式，直接把输入x传到输出作为初始结果，输出结果为H(x)=F(x)+x，当F(x)=0时，那么H(x)=x，也就是上面所提到的恒等映射。
    > 
    > 于是，ResNet相当于将学习目标改变了，不再是学习一个完整的输出，而是目标值H(X)和x的差值，也就是所谓的残差F(x) := H(x)-x，因此，后面的训练目标就是要将残差结果逼近于0，使到随着网络加深，准确率不下降。
    > 
    > 这种残差跳跃式的结构，打破了传统的神经网络n-1层的输出只能给n层作为输入的惯例，使某一层的输出可以直接跨过几层作为后面某一层的输入，其意义在于为叠加多层网络而使得整个学习模型的错误率不降反升的难题提供了新的方向。
    > 
    > 至此，神经网络的层数可以超越之前的约束，达到几十层、上百层甚至千层，为高级语义特征提取和分类提供了可行性。

#### 6.3 循环神经网络 RNN 

 *  循环神经网络通过使用带自反馈的神经元，能够处理任意长度的时序数据

![](https://i-blog.csdnimg.cn/blog_migrate/a61b2473337ba8206bbc9fe595fb849d.png)

 *  优点：  
    引入记忆  
    图灵完备
 *  缺点：  
    长程依赖问题  
    记忆容量问题  
    并行能力

#####  △ \\triangle △ CNN与RNN的区别 

区别就在循环层上。

卷积神经网络没有时序性的概念，不考虑数据之间的关联性；每次的输入都是独立的，网络的输出只和当前时刻的输入有关；

循环神经网络具有时序性，当前决策跟前一次决策有关。

相同点：  
传统神经网络的扩展；  
前向计算产生结果，反向计算模型更新；  
每层神经网络横向可以多个神经元共存，纵向可以有多层神经网络连接。

不同点：  
CNN空间扩展，神经元与特征卷积；RNN时间扩展，神经元与多个时间输出计算；  
RNN可以用于描述时间上连续状态的输出，有记忆功能，CNN用于静态输出；  
CNN高级100+深度，RNN深度有限。

#### 6.4 网络优化与正则化 

优化：风险最小化 正则化：降低模型复杂度

 *  网络优化
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/7af78f5befa415832a65bda9c6412e1b.png)
    
    难点：
    
     *  结构差异大
     *  非凸优化
     *  梯度消失 / 爆炸
 *  正则化
    
    ![<img src="C:\Users\lenovo.LAPTOP-MVJJVS9E\AppData\Roaming\Typora\typora-user-images\image-20211226212814284.png width="10%" " alt="image-20211226212814284" style="zoom:67%;" />](https://i-blog.csdnimg.cn/blog_migrate/86f064ca6caeb602f26168c9fc235486.png)


[chapter1]: #chapter1_25
[chapter2]: #chapter2_70
[2.1]: #21__76
[2.2]: #22__89
[_ _triangle _]: #triangle__114
[2.3]: #23__144
[2.4]: #24___150
[_ _triangle _ K]: #triangle__K_165
[2.5]: #25__192
[_ _triangle _ PR_P_R]: #triangle___PRPR_231
[_ _triangle _ ROC]: #triangle__ROC_258
[_ _triangle _ 1]: #triangle___283
[2.6]: #26__309
[2.7]: #27__325
[_ _triangle _ 2]: #triangle___333
[chapter3]: #chapter3_353
[3.1]: #31__359
[3.3 _ _triangle _ _Logistic]: #33_triangle__Logistic_403
[3.4 _ _triangle _ _ _LDA]: #34_triangle___LDA_447
[3.5]: #35__455
[3.6 _ _triangle _]: #36_triangle___467
[chapter4]: #chapter4_474
[_ _triangle _ 3]: #triangle___480
[_ _triangle _ 4]: #triangle___488
[SVM]: #SVM_496
[_ _triangle _ SVM]: #triangle__SVM_510
[_ _triangle _ _SVM]: #triangle__SVM_522
[_ _triangle _ 5]: #triangle___528
[_ _triangle _ SVM _ logistic]: #triangle__SVM__logistic__543
[Link 1]: #_589
[chapter5]: #chapter5_655
[_ _triangle _ 6]: #triangle___661
[5.1]: #51__678
[_ _triangle _ MP]: #triangle__MP_684
[_ _triangle _ sigmoid]: #triangle__sigmoid__716
[_ _triangle _ _ ReLU]: #triangle___ReLU_756
[5.2]: #52__783
[5.3 _ _triangle _]: #53_triangle___791
[5.4 _ _triangle _ _BP]: #54_triangle__BP_808
[_ _triangle _ 7]: #triangle___824
[5.5]: #55__833
[chapter6]: #chapter6_860
[6.1]: #61__866
[6.2 _ CNN]: #62__CNN_876
[_ _triangle _ 8]: #triangle__908
[_ _triangle _ CNN]: #triangle__CNN_932
[_ _triangle _ 9]: #triangle___941
[6.3 _ RNN]: #63___RNN_980
[_ _triangle _ CNN_RNN]: #triangle__CNNRNN_997
[6.4]: #64__1017